
import java.util.HashSet;
import java.util.Set;

class PinkJohn_CheckSudoKuSolution {
    // Function to check if a given row is valid. It will return:
    // -1 if the row contains an invalid value
    // 0 if thr row contains repeated values
    // 1 is the row is valid.

    public static int valid_row(int row, int[][] grid) {
        int temp[] = grid[row];
        Set<Integer> set = new HashSet<Integer>();
        for (int value : temp) {

            /*An integer value greater than 9 and a value less than 0 value is a bad value!!
            
Sudoku values can only go from 1 to 9 in a valid board. HOWEVER in this program 
 we will be working on REPLACING the 0  values in the board with valid values. 
      If we come across a 0 in a board we will just treat it as us ignoring the value.
       Thus multiple '0' inputs  will NOT trigger the invalid value/board issue.*/
            if (value < 0 || value > 9) {
                System.out.println("Invalid value");
                return -1;
            } //Checking for repeated values.
            else if (value != 0) {
                if (set.add(value) == false) {
                    return 0;
                }
            }
        }
        return 1;
    }
    // Function to check if a given column is valid. It will return:
    // -1 if the column contains an invalid value
    // 0 if the column contains repeated values
    // 1 is the column is valid.

    public static int valid_column(int column, int[][] grid) {
        Set<Integer> set = new HashSet<Integer>();
        for (int i = 0; i < 9; i++) {
            /*Checking for values outside 0 and 9. 0 is valid because it represents an
      empty spot on the board. Removing zeros and the checking for values and 
      outside 1 and 9 is another way of doing the same thing.*/
            if (grid[i][column] < 0 || grid[i][column] > 9) {
                System.out.println("Invalid value");
                return -1;
            } // Checking for repeated values.
            else if (grid[i][column] != 0) {
                if (set.add(grid[i][column]) == false) {
                    return 0;
                }
            }
        }
        return 1;
    }

    /* valid_3x3squares to check if all the 3x3 squares are valid. It will return: 
  -1 if a 3x3 square contains an invalid value. It will return 0 if a 3x3 square 
  contains repeated values. And it will return 1 if the 3x3 squares are valid.*/
    public static int valid_3x3squares(int[][] grid) {
        for (int row = 0; row < 9; row = row + 3) {
            for (int column = 0; column < 9; column = column + 3) {
                Set<Integer> set = new HashSet<Integer>();
                for (int row1 = row; row1 < row + 3; row1++) {
                    for (int column1 = column; column1 < column + 3; column1++) {

                        /*clearly a value less than 0 and greater than 9 would be INVALID in terms
        of our sudoku puzzle. Therefore we will tell the user: "This value is INVALID"
         0 is a valid input here because we still are completing the sudoku puzzle
            when we have 0 inputs (aka unfilled/unchanged boxes*/
                        if (grid[row1][column1] < 0 || grid[row1][column1] > 9) {
                            System.out.println("This value is INVALID");
                            return -1;
                        } // Checking for repeated values.
                        else if (grid[row1][column1] != 0) {
                            if (set.add(grid[row1][column1]) == false) {
                                return 0;
                            }
                        }
                    }
                }
            }
        }
        return 1;
    }
    //The method's 'valid_board' job will be to check if the board invalid.

    public static void valid_board(int[][] grid) {

        /*There are 3 cases that must be true for the sudoku board to be valid
      Case1 = Each number appears once in each row
      Case2 = Each number appears once in each column
      Case3 = Each number appears once in each 3x3 square
      
      If all conditions are fulfilled then the sudoku puzzle is a-ok.
         */
        for (int i = 0; i < 9; i++) {
            int case1 = valid_row(i, grid);
            int case2 = valid_column(i, grid);
            // if a row or column is invalid, then the ENTIRE board is invalid.
            if (case1 < 1 || case2 < 1) {
                System.out.println("The board is invalid.");
                return;
            }
        }
        int case3 = valid_3x3squares(grid);
        // if any one the subsquares is invalid, then the board is invalid.
        if (case3 < 1) {
            System.out.println("The board is invalid.\n");
        } else {
            System.out.println("The board is valid.\n");
        }
    }

    /*This method will print our board and format each number with a "," for ease of
  use for the user to visually see the board better*/
    public static void print_board(int[][] grid) {
        for (int[] row : grid) {
            //start each row with a bracket
            System.out.print("[");
            //the enhanced for loop will print a "," after each number in the row
            for (int y : row) {

                System.out.print(y + ", ");
            }
            //end each row with a bracket
            System.out.println("]");
        }
    }

    public static void main(String args[]) {
//Here we see a valid board
        int[][] board1 = {
            {4, 3, 5, 2, 6, 9, 7, 8, 1},
            {6, 8, 2, 5, 7, 1, 4, 9, 3},
            {1, 9, 7, 8, 3, 4, 5, 6, 2},
            {8, 2, 6, 1, 9, 5, 3, 4, 7},
            {3, 7, 4, 6, 8, 2, 9, 1, 5},
            {9, 5, 1, 7, 4, 3, 6, 2, 8},
            {5, 1, 9, 3, 2, 6, 8, 7, 4},
            {2, 4, 8, 9, 5, 7, 1, 3, 6},
            {7, 6, 3, 4, 1, 8, 2, 5, 9},};

        print_board(board1);
        valid_board(board1);

        /*Our board2 has a zero in the first row. By the conditons listed in 
in the project the board is technically valid since the '0' represents
        that we are NOT finished inputting numbers. There are no 
                other issues with the board so the board is valid still.*/
        int[][] board2 = {
            {4, 0, 5, 2, 6, 9, 7, 8, 1},
            {6, 8, 2, 5, 7, 1, 4, 9, 3},
            {1, 9, 7, 8, 3, 4, 5, 6, 2},
            {8, 2, 6, 1, 9, 5, 3, 4, 7},
            {3, 7, 4, 6, 8, 2, 9, 1, 5},
            {9, 5, 1, 7, 4, 3, 6, 2, 8},
            {5, 1, 9, 3, 2, 6, 8, 7, 4},
            {2, 4, 8, 9, 5, 7, 1, 3, 6},
            {7, 6, 3, 4, 1, 8, 2, 5, 9},};
        print_board(board2);
        valid_board(board2);

        //in the first row board 3 has 2 of the same number show. Board is invalid
        int[][] board3 = {
            {4, 4, 5, 2, 6, 9, 7, 8, 1},
            {6, 8, 2, 5, 7, 1, 4, 9, 3},
            {1, 9, 7, 8, 3, 4, 5, 6, 2},
            {8, 2, 6, 1, 9, 5, 3, 4, 7},
            {3, 7, 4, 6, 8, 2, 9, 1, 5},
            {9, 5, 1, 7, 4, 3, 6, 2, 8},
            {5, 1, 9, 3, 2, 6, 8, 7, 4},
            {2, 4, 8, 9, 5, 7, 1, 3, 6},
            {7, 6, 3, 4, 1, 8, 2, 5, 9}
        };
        print_board(board3);
        valid_board(board3);

        int[][] board4 = {
            
            /*board4 can be thought of as our default board. Yes, a COMPLETED
            sudoku puzzle does in fact only have the numbers 1 through 9 in it. 
            However our conditions state a '0' represents a box that has not been
            filled out yet. This is a board that has nothing on it. Though this 
            board may be impossible to fill out without starting digits on it.
            */
            {0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0},};
        print_board(board4);
        valid_board(board4);
        
        

    }
}
